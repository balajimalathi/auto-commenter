import { readFile, appendFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import type { Skill } from './skill-loader.js';

const DEFAULT_MEMORY_LINES = 50;

export interface MemoryEntry {
  timestamp: string;
  action: string;
  details: Record<string, string>;
  outcome: 'success' | 'failure' | 'skipped';
}

/**
 * Format a memory entry as a log line
 */
function formatEntry(entry: MemoryEntry): string {
  const detailsStr = Object.entries(entry.details)
    .map(([k, v]) => `${k}: ${v}`)
    .join(' | ');
  
  return `[${entry.timestamp}] Action: ${entry.action} | ${detailsStr} | Outcome: ${entry.outcome}`;
}

/**
 * Get current timestamp in HH:MM format
 */
function getTimestamp(): string {
  const now = new Date();
  return `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
}

/**
 * Read the last N lines of memory
 */
export async function readMemory(
  skill: Skill,
  lines: number = DEFAULT_MEMORY_LINES
): Promise<string> {
  const { memoryPath } = skill;

  if (!existsSync(memoryPath)) {
    return '(No previous activity recorded)';
  }

  try {
    const content = await readFile(memoryPath, 'utf-8');
    const allLines = content.trim().split('\n').filter(Boolean);
    const lastLines = allLines.slice(-lines);
    
    if (lastLines.length === 0) {
      return '(No previous activity recorded)';
    }

    return lastLines.join('\n');
  } catch {
    return '(No previous activity recorded)';
  }
}

/**
 * Append an entry to memory
 */
export async function appendMemory(
  skill: Skill,
  action: string,
  details: Record<string, string>,
  outcome: 'success' | 'failure' | 'skipped' = 'success'
): Promise<void> {
  const { memoryPath } = skill;

  const entry: MemoryEntry = {
    timestamp: getTimestamp(),
    action,
    details,
    outcome,
  };

  const line = formatEntry(entry) + '\n';

  try {
    await appendFile(memoryPath, line, 'utf-8');
  } catch {
    // If file doesn't exist, create it
    await writeFile(memoryPath, line, 'utf-8');
  }
}

/**
 * Log a comment action
 */
export async function logComment(
  skill: Skill,
  subreddit: string,
  postTitle: string,
  outcome: 'success' | 'failure' | 'skipped'
): Promise<void> {
  await appendMemory(skill, 'Comment posted', {
    subreddit: `r/${subreddit}`,
    post: postTitle.substring(0, 50) + (postTitle.length > 50 ? '...' : ''),
  }, outcome);
}

/**
 * Log a batch progress action
 */
export async function logBatchProgress(
  skill: Skill,
  subreddit: string,
  current: number,
  total: number
): Promise<void> {
  await appendMemory(skill, 'Batch step', {
    subreddit: `r/${subreddit}`,
    progress: `${current}/${total}`,
  }, 'success');
}

/**
 * Log a lead found action
 */
export async function logLeadFound(
  skill: Skill,
  subreddit: string,
  username: string,
  relevance: string
): Promise<void> {
  await appendMemory(skill, 'Lead found', {
    subreddit: `r/${subreddit}`,
    user: `u/${username}`,
    relevance,
  }, 'success');
}

/**
 * Log subreddit completion
 */
export async function logSubredditComplete(
  skill: Skill,
  subreddit: string,
  commentsPosted: number
): Promise<void> {
  await appendMemory(skill, 'Subreddit complete', {
    subreddit: `r/${subreddit}`,
    comments: commentsPosted.toString(),
  }, 'success');
}

/**
 * Log an error
 */
export async function logError(
  skill: Skill,
  action: string,
  error: string
): Promise<void> {
  await appendMemory(skill, action, {
    error: error.substring(0, 100),
  }, 'failure');
}

/**
 * Clear memory file (start fresh)
 */
export async function clearMemory(skill: Skill): Promise<void> {
  const { memoryPath } = skill;
  const header = `# Memory Log for ${skill.name}\n# Auto-generated by Agent0\n\n`;
  await writeFile(memoryPath, header, 'utf-8');
}

/**
 * Get memory summary stats
 */
export async function getMemoryStats(skill: Skill): Promise<{
  totalEntries: number;
  successCount: number;
  failureCount: number;
  lastActivity: string | null;
}> {
  const { memoryPath } = skill;

  if (!existsSync(memoryPath)) {
    return {
      totalEntries: 0,
      successCount: 0,
      failureCount: 0,
      lastActivity: null,
    };
  }

  const content = await readFile(memoryPath, 'utf-8');
  const lines = content.trim().split('\n').filter(l => l.startsWith('['));

  const successCount = lines.filter(l => l.includes('Outcome: success')).length;
  const failureCount = lines.filter(l => l.includes('Outcome: failure')).length;
  const lastLine = lines[lines.length - 1] || null;

  return {
    totalEntries: lines.length,
    successCount,
    failureCount,
    lastActivity: lastLine,
  };
}
